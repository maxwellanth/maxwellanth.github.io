<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Shader Background + Grain</title>
    <style>
      html, body { height: 100%; margin: 0; background: #0a0d12; }
      #bg { position: fixed; inset: 0; }
      /* Grain overlay */
      .grain {
        pointer-events: none;
        position: fixed; inset: 0;
        mix-blend-mode: overlay;   /* or soft-light */
        opacity: .15;
        filter: contrast(110%);
        background-image: url('data:image/svg+xml;utf8,\
<svg xmlns="http://www.w3.org/2000/svg" width=\\"160\\" height=\\"160\\">\
<filter id=\\"n\\">\
  <feTurbulence type=\\"fractalNoise\\" baseFrequency=\\"0.9\\" numOctaves=\\"1\\"/>\
  <feColorMatrix type=\\"saturate\\" values=\\"0\\"/>\
</filter>\
<rect width=\\"100%\\" height=\\"100%\\" filter=\\"url(%23n)\\"/>\
</svg>');
        background-size: 160px 160px;
      }

      /* Optional: center your login card so it “pops” over the motion */
      .card {
        position: relative; z-index: 2; 
        width: 360px; margin: 10vh auto; padding: 24px;
        background: rgba(15,18,24,.6); backdrop-filter: blur(8px);
        border: 1px solid rgba(255,255,255,.08); border-radius: 16px;
        color: #e7ecf3; font: 16px/1.5 system-ui, sans-serif;
      }
      .brand { font-weight: 700; font-size: 20px; letter-spacing: .02em; }
      label { display:block; margin-top:12px; font-size:14px; color:#b8c2cc; }
      input, button { width:100%; padding:10px 12px; border-radius:10px; border:1px solid #2a3340; background:#12161d; color:#e7ecf3; }
      button { margin-top:12px; border:1px solid #3d4a5c; cursor:pointer; }
      button:hover { border-color:#55657c; }
    </style>
  </head>
  <body>
    <canvas id="bg"></canvas>
    <div class="grain"></div>

    <div class="card">
      <div class="brand">Your Product</div>
      <label>Email</label><input type="email" />
      <label>Password</label><input type="password" />
      <button>Log in</button>
    </div>

    <script type="module">
      import * as THREE from "https://unpkg.com/three@0.161.0/build/three.module.js";
      const canvas = document.getElementById('bg');
      const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
      const scene = new THREE.Scene();
      const camera = new THREE.OrthographicCamera(-1,1,1,-1,0,1);

      const vert = /* glsl */`
        precision highp float;
        attribute vec2 position;
        varying vec2 vUv;
        void main() {
          vUv = (position + 1.0) * 0.5;
          gl_Position = vec4(position, 0.0, 1.0);
        }
      `;

      const frag = /* glsl */`
        precision highp float;
        uniform vec2  u_res;
        uniform float u_time;
        varying vec2  vUv;

        // 2D noise (iq’s hash/rot), quick and good enough for BGs
        float hash(vec2 p){ return fract(sin(dot(p, vec2(41.0, 289.0)))*43758.5453); }
        float noise(vec2 p){
          vec2 i=floor(p), f=fract(p);
          float a=hash(i), b=hash(i+vec2(1.,0.)), c=hash(i+vec2(0.,1.)), d=hash(i+vec2(1.,1.));
          vec2 u=f*f*(3.-2.*f);
          return mix(mix(a,b,u.x), mix(c,d,u.x), u.y);
        }
        // Fractal Brownian Motion
        float fbm(vec2 p){
          float v=0., a=.5; 
          for(int i=0;i<5;i++){ v+=a*noise(p); p*=2.0; a*=.5; }
          return v;
        }

        void main(){
          vec2 uv = vUv;
          // Base dark gradient (subtle vignette)
          vec3 base = mix(vec3(0.05,0.07,0.10), vec3(0.01,0.02,0.04), uv.y);

          // Animate coordinates to create a slow “flow”
          float t = u_time * 0.06;
          vec2 p = uv * 3.0;
          // slight drift & swirl
          p += vec2(sin(t*0.7)*0.2, cos(t*0.6)*0.2);
          float n = fbm(p + fbm(p + t));

          // Colorize the noise: teal–magenta gamut (tweak to taste)
          vec3 c1 = vec3(0.05, 0.71, 0.78);
          vec3 c2 = vec3(0.78, 0.21, 0.66);
          vec3 glow = mix(c1, c2, smoothstep(0.2, 0.9, n));

          // Blend the glow softly over the base
          vec3 col = base + glow * 0.25;

          // Soft vignette
          float d = distance(uv, vec2(0.5));
          col *= smoothstep(0.95, 0.45, d);

          // Slight contrast lift
          col = pow(col, vec3(0.95));
          gl_FragColor = vec4(col, 1.0);
        }
      `;

      // Fullscreen quad
      const geometry = new THREE.BufferGeometry();
      const vertices = new Float32Array([
        -1,-1,  1,-1, -1, 1,
         1,-1,  1, 1, -1, 1
      ]);
      geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 2));

      const material = new THREE.RawShaderMaterial({
        vertexShader: vert, fragmentShader: frag,
        uniforms: {
          u_res:  { value: new THREE.Vector2() },
          u_time: { value: 0 }
        }
      });
      const mesh = new THREE.Mesh(geometry, material);
      scene.add(mesh);

      function resize(){
        const dpr = Math.min(window.devicePixelRatio || 1, 2);
        renderer.setPixelRatio(dpr);
        renderer.setSize(window.innerWidth, window.innerHeight, false);
        material.uniforms.u_res.value.set(renderer.domElement.width, renderer.domElement.height);
      }
      window.addEventListener('resize', resize);
      resize();

      let t0 = performance.now();
      (function loop(){
        material.uniforms.u_time.value = (performance.now() - t0) / 1000;
        renderer.render(scene, camera);
        requestAnimationFrame(loop);
      })();
    </script>
  </body>
</html>
